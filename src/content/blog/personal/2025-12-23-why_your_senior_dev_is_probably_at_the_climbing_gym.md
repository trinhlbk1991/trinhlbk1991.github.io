---
title: "Why Your Senior Dev is Probably at the Climbing Gym"
date: 2025-12-23
categories: ["personal"]
tags: ["Personal", "Climbing"]
summary: "Bouldering isn't just a sport—it's physical programming. Here's why so many software engineers are obsessed with climbing gyms."
toc: true
comments: true
image: "/assets/images/personal/me-climbing.jpg"
---

It's been a while since my last post on [Iced Tea Labs](https://icedtealabs.com).

Yep, I started bouldering at one of the coolest climbing gyms in Ho Chi Minh City—[Vertical District](https://verticaldistrict.vn/)! And I noticed something funny: the place was packed with *software engineers*.

At first, I was curious why. But the more I climbed (and fell off the wall), the more I realized that bouldering isn't just a sport... it's **physical programming**.

Here is why your Senior Dev is probably at the climbing gym right now.

<img src="/assets/images/personal/me-climbing.jpg"  alt="Me climbing at Vertical District to run away from my actual problems"/>

## The "Problems"

In many other sports, you have a "match," a "game," or a "race." But in bouldering, the route is literally called a **"boulder problem."**

Just like in software, a problem is defined clearly with a set of requirements and constraints:
*   **Start position:** You have to establish the start with specific holds (usually marked by tapes).
*   **Finish position:** Both hands controlled on the top hold.
*   **Constraints:** You can only use holds of a specific color.

<img src="/assets/images/personal/ifsc.jpg"  alt="Tapes on hold to indicate how many limbs climber have to use on specific holds for the starting position"/>

When you're new to bouldering, you might look at a problem and try to muscle through it—like a Junior Dev trying to brute-force a solution. But a Senior Dev knows that brute force burns your resources (your muscles) in no time. You have to find the algorithm.

## The "Beta"

In bouldering, "Beta" is the specific sequence of moves you need to send (solve) the problem.

Surprisingly, the steps to solving a boulder problem are nearly identical to debugging a crashing app:
1.  **Run the code:** You attempt the climb.
2.  **Runtime exception:** You fall off the wall.
3.  **Analyze the logs:** "Why did I fall? Was my foot placement wrong?"
4.  **Patch the bug:** "Okay, this time I'll toe hook to prevent barndooring."
5.  **Re-deploy:** Try the climb again.

And when you can't figure out why you can't send the route? The climbing community is always there to share the beta with you—just like looking for help on StackOverflow.

<img src="/assets/images/personal/community.webp"  alt="The supportive and destructive community in climbing is one of the best"/>

## The "Optimal" Solution

In bouldering, reaching the top isn't the only goal. The more you climb, the more you want to climb *efficiently* to conserve energy, rather than just using raw strength.

Sometimes, just a little twist of your hips or straightening your arms can make a huge difference. It's like improving your code from an **O(n²)** to an **O(n)** approach. It's the physical manifestation of "clean code."

<img src="/assets/images/personal/dropknee.jpg"  alt="Dropknee is one of the core techniques help you to climb more efficiently"/>

## Why do Software Engineers love Climbing?

Besides the similarities between climbing and coding, I think the reason so many of us are obsessed with the gym is the **feedback loop**.

In software, we build features, fix bugs, and refactor code, often waiting weeks for user feedback.

In bouldering, the feedback is instant and undeniable! You either held the rock, or you fell. Gravity doesn't care about your edge cases. When you finally reach the top, you get a hit of dopamine that is remarkably similar to fixing a bug that's been plaguing you for a week—but you also get to feel it in your muscles.

***

I'm back to writing on [Iced Tea Labs](https://icedtealabs.com), and I plan to bring some of that "climber mindset" back to my development tutorials. Whether it's [Buckist](http://buckist.app/), myMoney, or a new Flutter experiment, I'm treating it like a new project on the wall: analyze, attempt, fail, adjust, and send.

See you on the wall (or in the terminal)!
